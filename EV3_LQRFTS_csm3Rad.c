#pragma config(Sensor, S4,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Motor,  motorA,          A,             tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,          C,             tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Sensor, S1,     HTAC,           sensorNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//#include "hitechnic-accelerometer.h"
//=====================================================================
// HiTechnic HTWay Version 1.1
// Copyright (c) 2010 HiTechnic
//
// Revision History
//   1.1    Fixed a bug that prevented the HTWayC program from working
//          correctly when optimization level was set to 2.
//          Also imporived the accuracy of the initial gyro offset
//          caluculation by ensuring the motor controller in active.
//
// Gyro based sample Segway type robot. This NXC program uses the LEGO
// 2.0 firmware which has floating point support.  It has been tested
// with LEGO NXT firmware 1.29.
//
// To use the floating point math available in the 2.0 firmware,
// BricxCC must be setup to tell the compiler to target that firmware.
// From the Edit menu, select Preferences.  Select the Compiler tab,
// and then NBC/NXC sub-tab and check 'NXT 2.0 compatible firmware.'

#define Left_Motor   motorC
#define Right_Motor  motorA
//=====================================================================
// Balancing constants
//
// These are the constants used to maintain balance.
//
// Loop wait time.  WAIT_TIME is the time in ms passed to the
// Wait command.
#define WAIT_TIME    1
// Wheel ratio is relative size compared to NXT 1.0 wheels
// For the NXT 1.0 wheels (56x26) use:           1.0
// For the NXT 2.0 wheels (43.2x22) use:         0.7
// For the big white RCX wheels (81.6x15) use:   1.4
#define WHEEL_RATIO_NXT2 0.7
// These are the main four balance constants, only the gyro
// constants are relative to the wheel size.  KPOS and KSPEED
// are self-relative to the wheel size.
#define KPOS        	0.2					//-0.1 -0.4472
#define KSPEED      	0.32
// Power differential used for steering based on difference of
// target steering and actual motor difference.
#define KSTEER      0.25
// Gyro offset control
// The gyro sensor will drift with time.  This constant is used in a
// simple long term averaging to adjust for this drift.
// Every time through the loop, the current gyro sensor value is
// averaged into the gyro offset weighted according to this constant.
#define EMAOFFSET 0.0005
// If robot power is saturated (over +/- 100) for over this time limit
// then robot must have fallen.  In milliseconds.
#define TIME_FALL_LIMIT     1000
//=====================================================================
// Global variables
//
// These variables are used to control the movement of the robot.  Both
// are in degrees/second.
// Time that robot first starts to balance.  Used to calculate tInterval
long tCalcStart;
// tInterval is the time, in seconds, for each iteration of the
// balance loop.
float tInterval;
// Gyro globals
float gOffset;
float gAngleGlobal = 0;
// This is the gain that is computed adaptively based on the battery voltage (as the battery is drained, the gain is increased)
float kBatteryAdjustGain;
// Motor globals
long mrcSum = 0, mrcSumPrev;
long motorDiff;
float mrcPosPrev = 0;
//float mrcFilter;
//float mrcFilterPrev=0;
long mrcDeltaP3 = 0;
long mrcDeltaP2 = 0;
long mrcDeltaP1 = 0;
long IntMotor = 0;
float x=0.0;
float y=0.0;
int temp=0;

float xvec[3]={0,0,0};
float K[108]={9.8763,-9.0005,-39.3735,3.1779,-0.7342,0.4363,0.1155,0.0219,8.5345,60.0767,-33.374,-3.3613,-0.5514,-221.663,-2.4057,-0.2873,-0.5696,
	-50.8067,-8.7611,-1.0386,-0.6141,-26.3854,-31.578,-1.3437,8.7612,-1.5101,0.0051,0.0077,-1.0602,-57.2766,-4.4587,-0.464,-7.4211,188.1111,-0.5983,
	-0.1527,-1.3867,-1.477,0.1141,0.0223,0.0329,-67.3669,-3.6732,-0.4581,-1.0071,-72.3713,-2.8396,-0.3569,0.0256,-33.6158,-10.4511,-1.375,0.0027,
	-80.1586,-8.588,-1.1097,0.0364,0.0181,0.0182,0.01,-1.159,-22.9701,-4.668,-0.5993,-0.132,-85.2105,-6.1147,-0.7747,-10.4303,-149.6082,12.7654,0.7442,
	4.9017,-60.2113,0.7905,0.0979,0.1641,61.2595,6.6094,0.9055,-12.0533,-56.9778,-91.8117,-11.2209,0.7746,-14.9452,-21.7933,-1.2439,0.2704,-68.2792,
	-9.085,-1.079,0.6667,-16.2791,-12.0159,-1.01,-17.9905,26.2164,-44.0306,-3.6286,0.0179,0.63,0.1192,0.0229,-3.4642,-9.8713,-0.1473,-0.0117};
float Y[108];
float w[27];
//const float Rangs[6]={-28.2477,27.5702,-496.2726,496.3778,-5823,6062.8};
const float Rangs[6]={-0.493,0.4812,-8.6616,8.6634,-101.6306,105.8157};
float Beta[27];
float Fuzz[3][3];

//=================================================================  ====
void GetGyroOffset();
float LQRFTS();
void FuzzyWeight();
void FuzzyfierT();
float Trapecio(float p1, float p2, float p3, float p4, float p5, float p6, float x);
float Triangulo(float p1,float p2,float p3,float p4,float p5,float x);
void SteerControl(float power, int &powerLeft, int &powerRight);
void GetMotorData(float &motorSpeed, float &motorPos);
void CalcInterval(long cLoop);
void GetGyroData(float &gyroSpeed, float &gyroAngle);

//=====================================================================
// task main - initializes the sensors, Both taskBalance and
// taskController start when main ends.
task main (){
	//Definición de variables
	float gyroSpeed = 0;
	float gyroAngle = 0;
	float motorSpeed = 0;
	float motorPos = 0;
	float integral = 0;
	float motorante = 0;
	float power;
	int powerLeft, powerRight;
	long tMotorPosOK;
	long cLoop = 0;

	GetGyroOffset();
	resetMotorEncoder(Left_Motor);
	resetMotorEncoder(Right_Motor);
	//Imprime en pantalla en valor calibrado
	eraseDisplay();
	displayStringAt(0,48,"OffsetGyro %f",gOffset);
	// Toma referencia inicial de tiempo para detección de caida del robot
	tMotorPosOK = time1[T1];
	// Ciclo de control
	while(true) {
		// Calcula el tiempo promedio de ciclo de control
		CalcInterval(cLoop++);
		// Toma una muestra del subvector de estado relacionado con el sensor de giro
		GetGyroData(gyroSpeed, gyroAngle);
		// Toma una muestra del subvector de estado relacionado con el encoder de las ruedas
		GetMotorData(motorSpeed, motorPos);
		// Aplica el valor de control de avance a la posicion del motor para lograr el robot se mueva.
		// Ley de control
		xvec[0]=gyroAngle;
    xvec[2]=motorSpeed;
    xvec[1]=gyroSpeed;
    integral=(motorPos-motorante)/tInterval;
    power=-LQRFTS()+ KPOS * motorPos + integral * KSPEED;
		motorante=motorPos;
		// Función que ajusta la energía para cada motor ajustando el error de deslizamiento de las ruedas
		SteerControl(power, powerLeft, powerRight);
		// Aplicación de la energía a los motores
		motor[Left_Motor] = powerLeft;
		motor[Right_Motor] = powerRight;
		//power=0;
		// Se revisa si el robot ha caido revisando si se ha excedido el limite de energía por más de un tiempo limite
		if (abs(power) < 100)
			tMotorPosOK = time1[T1];
		/*if ((time1[T1] - tMotorPosOK) > TIME_FALL_LIMIT) {
			break;
		}*/
		// Tiempo de espera que homogeniza el tiempo de inferencia de control 100 inferencias por segundo
		wait1Msec(WAIT_TIME);
	}
	// Detención de motores en caso de caida del robot
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;
}
//---------------------------------------------------------------------
// void CalcInterval(long cLoop)
//
// Calculate the interval time from one iteration of the loop to the next.
// Note that first time through, cLoop is 0, and has not gone through
// the body of the loop yet.  Use it to save the start time.
// After the first iteration, take the average time and convert it to
// seconds for use as interval time.
void CalcInterval(long cLoop){
	if (cLoop == 0) {
		// First time through, set an initial tInterval time and
		// record start time
		tInterval = 0.0055;
		tCalcStart = time1[T1];
		} else {
		// Take average of number of times through the loop and
		// use for interval time.
		tInterval = (time1[T1] - tCalcStart)/(cLoop*1000.0);
	}
	writeDebugStream("%f ", nPgmTime);
}
//=====================================================================
// GetGyroData(float &gyroSpeed, float &gyroAngle)
//
// Get the data from the gyro.
// Fills the pass by reference gyroSpeed and gyroAngle based on
// updated information from the Gyro Sensor
//
// Maintains an automatically adjusted gyro offset as well as
// the integrated gyro angle.
void GetGyroData(float &gyroSpeed, float &gyroAngle){
	float gyroRaw;
	gyroRaw = getGyroRate(gyroSensor);
	gOffset = EMAOFFSET * gyroRaw + (1-EMAOFFSET) * gOffset;
	gyroSpeed = gyroRaw - gOffset;
	gyroSpeed=gyroSpeed*(3.1416/180);
	gAngleGlobal += gyroSpeed*tInterval;
	gyroAngle = gAngleGlobal;
	writeDebugStream("%f ", gyroSpeed);
	writeDebugStream("%f ", gyroAngle);
}
//=====================================================================
void GetMotorData(float &motorSpeed, float &motorPos){
	long mrcLeft, mrcRight;
	float mrcDelta;
	// Keep track of motor position and speed
	mrcLeft = nMotorEncoder[Left_Motor];
	mrcRight = nMotorEncoder[Right_Motor];
	// Maintain previus mrcSum so that delta can be calculated and get
	// new mrcSum and Diff values
	mrcSumPrev = mrcSum;
	mrcPosPrev = IntMotor;
	mrcSum = (mrcLeft + mrcRight);
	motorDiff = (mrcLeft - mrcRight);
	// mrcDetla is the change int sum of the motor encoders, update
	// motorPos based on this detla
	mrcDelta = (mrcSum - mrcSumPrev)*(3.1416/180);
	motorPos += mrcDelta;
	//Integral de la posicion
	IntMotor=mrcPosPrev+tInterval*motorPos;
	// motorSpeed is based on the average of the last four delta's.
	motorSpeed = (mrcDelta+mrcDeltaP1+mrcDeltaP2+mrcDeltaP3)/(4*tInterval);
	// Shift the latest mrcDelta into the previous three saved delta values
	mrcDeltaP3 = mrcDeltaP2;
	mrcDeltaP2 = mrcDeltaP1;
	mrcDeltaP1 = mrcDelta;
	writeDebugStream("%f ", motorSpeed);
  writeDebugStream("%f ", motorPos);
}
//=====================================================================
// void SteerControl(int power, int &powerLeft, int &powerRight)
//
// This function determines the left and right motor power that should
// be used based on the balance power and the steering control
void SteerControl(float power, int &powerLeft, int &powerRight){
	int batt, power_adj;
	//const int kMaxBattery = 10000;
	//const int kMinBattery = 7000;
	batt = getBatteryVoltage();
	//kBatteryAdjustGain = 9 + (2 / (kMaxBattery - kMinBattery)) * (kMaxBattery - batt);
	kBatteryAdjustGain = 10;
	power_adj=kBatteryAdjustGain*power;
	//writeDebugStream("%f ", batt);
	// Apply the power steering value with the main power value to
	// get the left and right power values.
	if((ceil(x)-x)<=0.25){
  		y=50;
  		temp=1;}
  else if(temp==1)
  		y=0;
  else
    	y=0;
	powerLeft = power_adj-(KSTEER*motorDiff);//+y;
	powerRight = power_adj+(KSTEER*motorDiff);//+y;

	// Limit the power to motor power range -100 to 100
	if (powerLeft > 100)   powerLeft = 100;
	if (powerLeft < -100)  powerLeft = -100;
	// Limit the power to motor power range -100 to 100
	if (powerRight > 100)  powerRight = 100;
	if (powerRight < -100) powerRight = -100;
	x=x+0.006;
	//writeDebugStream("%f ", powerRight);
	writeDebugStreamLine("%f ", power);
}
//=====================================================================
// GetGyroOffset
//
// This function returns a suitable initial gyro offset.  It takes
// 100 gyro samples over a time of 1/2 second and averages them to
// get the offset.  It also check the max and min during that time
// and if the difference is larger than one it rejects the data and
// gets another set of samples.
#define OFFSET_SAMPLES 100
void GetGyroOffset(){
	float gSum;
	float gyroRaw;
	int  i, gMin, gMax;
	eraseDisplay();
	displayStringAt(0,48,"NV3 Salle SegWay");
	displayStringAt(0,32,"Lay robot down");
	displayStringAt(0,24,"flat to get gyro");
	displayStringAt(0,16,"offset.");
	resetGyro(gyroSensor);
	gyroRaw = getGyroRate(gyroSensor);
	while((gyroRaw==0.0 || abs(gyroRaw)>440)){
		gyroRaw = getGyroRate(gyroSensor);
		writeDebugStreamLine("Esperando tiempo muerto");
	}

	do {
		gSum = 0.0;
		gMin = 1000;
		gMax = -1000;
		for (i=0; i<OFFSET_SAMPLES; i++) {
			gyroRaw = getGyroRate(gyroSensor);

			if (gyroRaw > gMax)
				gMax = gyroRaw;
			if (gyroRaw < gMin)
				gMin = gyroRaw;
			gSum += gyroRaw;
			wait1Msec(5);
		}
	} while ((gMax - gMin) > 1);   // Reject and sample again if range too large
		//Average the sum of the samples.
	gOffset = gSum / OFFSET_SAMPLES + 1.0;
	// Even with motor controller active, the initial offset appears to
	// be off from the actual needed offset to keep robot from wondering.
	// This +1 helps keep robot from wondering when it first starts to
	// balance.
	// gOffset = 0;
	playSound(soundBlip);   // play a sound when the training is over
	return;

}

float LQRFTS()
{
  int i,j;
  float u=0;
  float x[4]={1,xvec[0],xvec[1],xvec[2]};
  FuzzyWeight();
  for (i=0; i<27; i++)
  {
    for (j=0; j<4; j++)
    {
      Y[i*4+j]=x[j]*Beta[i];
    }
  }
  for (i=0; i<108; i++){
  	u=u+K[i]*Y[i];
  }
  return u;
}

void FuzzyWeight()
{
  int i,j,k;
  int n=0;
  float den=0;
  FuzzyfierT();
  n=0;
  den=0;
  for (i=0; i<3; i++)
  {
    for (j=0; j<3; j++)
    {
      for (k=0; k<3; k++)
      {
        w[n]=Fuzz[0][i]*Fuzz[1][j]*Fuzz[2][k];
        den=den+w[n];
        n=n+1;
      }
    }
  }
  for (i=0; i<27; i++)
  {
    Beta[i]=w[i]/den;
  }
}

void FuzzyfierT()
{
  int i;
  float p1,p2,p3,p4,p5,p6,delta;

  for (i=0; i<3; i++)
  {
     for (int j = 0; j < 3; j++)
     {
     	delta=(abs(Rangs[(2*i)+1]-Rangs[2*i]))/2;
     	if (j==0)
     	{
     		p1=Rangs[2*i]-delta;
            p2=p1;
            p3=p2;
            p4=p3+delta;
            p5=p4+delta;
            p6=Rangs[2*i+1]+delta;
            Fuzz[i][j]=Trapecio(p1,p2,p3,p4,p5,p6,xvec[i]);
     	}else if (j==3)
     	{
     		p1=Rangs[2*i]-delta;
            p2=Rangs[2*i+1]-delta;
            p3=p2+delta;
            p4=p3+delta;
            p5=p4;
            p6=p5;
            Fuzz[i][j]=Trapecio(p1,p2,p3,p4,p5,p6,xvec[i]);
     	}else
     	{
     		p1=Rangs[2*i]-delta;
            p2=p1+j*delta;
            p3=p2+delta;
            p4=p3+delta;
            p5=Rangs[2*i+1]+delta;
            Fuzz[i][j]=Triangulo(p1,p2,p3,p4,p5,xvec[i]);
    	}
     }
  }
}

float Trapecio(float p1,float p2,float p3,float p4,float p5,float p6,float x)
{
  float y=0;
  if (x>=p1&&x<p2)
  {
    y=0;
  }
  else
  {
    if (x>=p2&&x<p3)
    {
      y=(x-p2)/(p3-p2);
    }
    else
    {
      if (x>=p3&&x<p4)
      {
        y=1;
      }
      else
      {
        if (x>=p4&&x<p5)
        {
          y=(x-p5)/(p4-p5);
        }
        else
        {
          if (x>=p5&&x<p6)
          {
            y=0;
          }
          else
          {
            y=2;
          }
        }
      }
    }
  }
  return y;
}

float Triangulo(float p1,float p2,float p3,float p4,float p5,float x)
{
  float y=0;
  if (x>=p1&&x<p2)
  {
    y=0;
  }
  else
  {
    if (x>=p2&&x<p3)
    {
      y=(x-p2)/(p3-p2);
    }
    else
    {
      if (x>=p3&&x<p4)
      {
        y=(x-p4)/(p3-p4);
      }
      else
      {
        if (x>=p4&&x<p5)
        {
          y=0;
        }
        else
        {
          y=2;
        }
      }
    }
  }
  return y;
}
